#!/bin/bash

DOTFILES_ROOT_DIR=$(pwd)

# Check for dotfiles root
GIT_DIR=$(grep ivan-ristovic/dotfiles .git/config)
if [ -z "$GIT_DIR" ]; then
    echo "Not in dotfiles directory. Exiting ..."
    exit 1
fi
required_dirs=("include" "install")
for dir in "${required_dirs[@]}"; do
    if [ ! -d "$dir" ]; then
        echo "$dir/ directory is not present. Exiting ..."
        exit 1
    fi
done

# Load utils
export SHLIB_ROOT="$PWD/include"
source "utils.sh"

function usage ()
{
    echo -e "usage: $0"
    echo -e "\t[--user username | -u username]"
    echo -e "\t[--dotfiles | --packages install_list_path | --patch[es] --services | --complete]"
    echo -e "\t[--verbose | -v] [--strict | -s]"
    echo -e "\t[--log | -l]"
    echo -e "\t[--help | -h]"
    echo
    echo "  LEGEND:"
    echo -e "\t--help -h             prints this manual"
    echo -e "\t--strict -s           halt on error (set -e)"
    echo -e "\t--verbose -v          runs the script in debug mode (set -x)"
    echo -e "\t--remote              update git remote URL"
    echo -e "\t--log -l              output log to logfile"
    echo
    echo -e "\t--dotfiles            link dotfiles (default)"
    echo -e "\t--packages --install  install packages from the given install list"
    echo -e "\t--patch --patches     perform patches"
    echo -e "\t--complete --all      perform all of the above"
    exit 2
}

GIT_REMOTE="git@github.com:ivan-ristovic/dotfiles.git"

SETUP_OVERRIDE=false
SETUP_DOTFILES=false
SETUP_PACKAGES=false
SETUP_PATCHES=false
SETUP_SERVICES=false
SETUP_USER=${SUDO_USER:-$(logname 2> /dev/null)}
SETUP_HOME_DIR="/home/$SETUP_USER"

SHORT_OPTS=v,s,u:,h,l
LONG_OPTS=user:,username:,dotfiles,link,stow,packages,install,dotfiles,patch,patches,services,all,complete,help,strict,debug,verbose,remote,git,log
OPTS=$(getopt --alternative --name 'argument error' --options $SHORT_OPTS --longoptions $LONG_OPTS -- "$@") 
if [ $? -ne 0 ]; then
    std::fat "failed to parse provided arguments"
fi
eval set -- $OPTS

while :
do
    case "$1" in
        --all | --complete)
            SETUP_OVERRIDE=true
            SETUP_DOTFILES=true
            SETUP_PACKAGES=true
            SETUP_PATCHES=true
            SETUP_SERVICES=true
            ;;
        --packages | --install)
            SETUP_OVERRIDE=true
            SETUP_PACKAGES=true
            ;;
        --dotfiles | --link | --stow)
            SETUP_OVERRIDE=true
            SETUP_DOTFILES=true
            ;;
        --patch | --patches)
            SETUP_OVERRIDE=true
            SETUP_PATCHES=true
            ;;
        --services)
            SETUP_OVERRIDE=true
            SETUP_SERVICES=true
            ;;
        --remote | --git)
            if git remote set-url origin $GIT_REMOTE ; then
                fmt::suc "Successfully updated remote: $GIT_REMOTE"
                exit 0
            else 
                fmt::err "Failed to update remote"
                exit $?
            fi
            ;;
        -l | --log)
            logfile="setup-$(date +%s).log"
            fmt::msg "logging output to: $logfile"
            exec 1> >(tee -a $logfile)
            exec 2>&1
            ;;
        -v | --verbose | --debug)
            fmt::msg "debug mode enabled"
            set -x; 
            ;;
        -s | --strict)
            fmt::msg "strict mode enabled"
            set -e; 
            ;;
        -u | --user | --username)
            SETUP_USER="$2"
            SETUP_HOME_DIR="/home/$SETUP_USER"
            shift;
            ;;
        -h | --help)
            usage
            ;;
        --)
            shift;
            break
            ;;
        *)
            fmt::err "unknown option: $1"
            usage
            ;;
    esac
    shift;
done

# Check if install arg exists
if $SETUP_PACKAGES ; then
    if [ $# -eq 0 ]; then
        std::fat "missing install list(s) or entries to install"
    fi
fi

# Check if running as root if setting up packages or patches
if $SETUP_PACKAGES || $SETUP_PATCHES; then 
    if [ "$EUID" -ne 0 ]; then 
        std::fat "installing/patching requires root access"
    fi
fi

# Check username
if [ -z "$SETUP_USER" ]; then
    std::fat "cannot automatically detect user name - please provide one using the --username option"
fi

# Check home dir
if [ ! -d "$SETUP_HOME_DIR" ]; then
    std::fat "invalid home directory: $SETUP_HOME_DIR"
fi

if ! $SETUP_OVERRIDE ; then 
    SETUP_PACKAGES=false
    SETUP_DOTFILES=true
    SETUP_PATCHES=false
    SETUP_SERVICES=false
fi

fmt::msg "user: $SETUP_USER"
fmt::msg "home dir: $SETUP_HOME_DIR"
fmt::msg "install list: $*"

export SETUP_USER
export SETUP_HOME_DIR


### Start setup

packages_requiring_linked_dotfiles=()
errored_entries=()

if $SETUP_PACKAGES ; then

    fmt::suc "Starting installations; command: '$PM_INSTALL_CMD'"

    function process_list ()
    {
        for entry in "$@"; do
            cd "install"
            SETUP_SCRIPT="$entry"
            AUR_PREFIX="aur:"
            if [[ "$entry" == "+"* ]]; then
                cd "$DOTFILES_ROOT_DIR"
                to_include=${entry#"+"}
                fmt::msg "Importing setup script: $to_include"
                process_list $(read_list "lists/$to_include")
            elif [[ "$entry" == "!"* ]]; then
                to_post_install=${entry#"!"}
                fmt::msg "Post-link install for : $to_post_install"
                packages_requiring_linked_dotfiles+=(${to_post_install})
            elif [ -f "$SETUP_SCRIPT" ]; then
                fmt::msg "Setting up via script : $entry"
                source ./"$SETUP_SCRIPT"
            elif [[ "$entry" == "$AUR_PREFIX"* ]]; then
                pkg=${entry#"$AUR_PREFIX"}
                fmt::msg "Installing from AUR   : $pkg"
                if inst_aur "$pkg"; then
                    fmt::suc "Successfully installed: $pkg"
                else
                    errored_entries+=(${entry})
                fi
            else
                fmt::msg "Installing package    : $entry"
                if inst "$PM" "$entry"; then
                    fmt::suc "Successfully installed: $entry"
                else
                    errored_entries+=(${entry})
                fi
            fi
            cd "$DOTFILES_ROOT_DIR"
            sleep 1
        done
    }

    for arg in "$@" ; do
        if [[ "$arg" == "install/"* ]]; then
            fmt::msg "Ignoring install/ pfix: $arg"
            arg=${arg#"install/"}
        fi
        if [ -f "$arg" ]; then
            process_list $(read_list "$arg")
        else
            process_list "$arg"
        fi
    done

    fmt::suc "Installations finished."
fi


if $SETUP_DOTFILES ; then
    # Ensure .config dir exists so that it is not
    # symlinked (otherwise all programs would dump
    # their config into the dotfiles directory)
    mkdir -p "$SETUP_HOME_DIR/.config"

    # Force overwrites of specified files (save backup to /tmp)
    backup_dir=/tmp/dotfiles
    rm -rf $backup_dir
    force_overwrite_list=$(read_list ".link.force")
    for entry in $force_overwrite_list; do
        entry_path="$SETUP_HOME_DIR/$entry"
        if [[ -f $entry_path && ! -h $entry_path ]]; then
            mkdir -p $backup_dir
            fmt::msg "Forcing overwrite of: $entry_path ; backup at $backup_dir"
            mv "$entry_path" "$backup_dir"
        fi
    done

    cd dotfiles
    if stow --no-folding -v . -t "$SETUP_HOME_DIR" ; then 
        fmt::suc "Dotfiles linked."
    else
        fmt::err "Failed linking dotfiles! Backup is kept at: $backup_dir"
    fi
    cd "$DOTFILES_ROOT_DIR"
    
    unset backup_dir
    unset force_overwrite_list
fi

if $SETUP_PATCHES ; then
    patches_dir="patches"
    patches_script="patch"
    if [ -d "$patches_dir" ]; then
        cd $patches_dir
        if [ -f "$patches_script" ]; then
            source ./"$patches_script"
        else
            fmt::err "$patches_dir/$patches_script script is not present."
        fi
    else
        fmt::err "$patches_dir/ directory is not present."
    fi
    unset patches_dir
    unset patches_script
    cd "$DOTFILES_ROOT_DIR"
fi

if $SETUP_SERVICES ; then
    services_dir="systemd"
    services_script="setup_services"
    if [ -d "$services_dir" ]; then
        cd $services_dir
        if [ -f "$services_script" ]; then
            source ./"$services_script"
        else
            fmt::err "$services_dir/$services_script script is not present."
        fi
    else
        fmt::err "$services_dir/ directory is not present."
    fi
    unset services_dir
    unset services_script
    cd "$DOTFILES_ROOT_DIR"
fi

if $SETUP_PACKAGES ; then
    process_list "${packages_requiring_linked_dotfiles[@]}"

    for errored_entry in "${errored_entries[@]}"; do
        fmt::err "Failed to install: $errored_entry"
    done
fi

unset SETUP_USER
unset SETUP_HOME_DIR

fmt::suc "Done! Have a nice day."

